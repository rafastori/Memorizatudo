<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mandarin Deep Thinking</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#047857">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3344/3344304.png">
    
    <!-- Fonts & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Biblioteca Pinyin (CRUCIAL PARA A CORREÇÃO) -->
    <script src="https://unpkg.com/pinyin-pro@3.18.3/dist/index.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'], chinese: ['Noto Sans SC', 'sans-serif'] },
                    colors: { brand: { 50: '#ecfdf5', 100: '#d1fae5', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46' } },
                    animation: { 'shake': 'shake 0.4s cubic-bezier(.36,.07,.19,.97) both', 'pop': 'pop 0.3s ease-out forwards', 'pulse-slow': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' },
                    keyframes: {
                        shake: { '10%, 90%': { transform: 'translate3d(-1px, 0, 0)' }, '20%, 80%': { transform: 'translate3d(2px, 0, 0)' }, '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0)' }, '40%, 60%': { transform: 'translate3d(4px, 0, 0)' } },
                        pop: { '0%': { transform: 'scale(0.95)', opacity: 0 }, '100%': { transform: 'scale(1)', opacity: 1 } }
                    }
                }
            }
        }
    </script>

    <!-- React & Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body, html { height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #f8fafc; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .perspective-1000 { perspective: 1000px; }
        .transform-style-3d { transform-style: preserve-3d; }
        .backface-hidden { backface-visibility: hidden; }
        .rotate-y-180 { transform: rotateY(180deg); }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body>
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;
        const { pinyin } = pinyinPro; // Acesso à biblioteca

        // --- DADOS (Compactados) ---
        const studyData = [
            { id: 1, chinese: "看来你对 Gemini 3 的发布非常兴奋！在 YouTube 上确实有很多关于人工智能（AI）的热烈讨论。", pinyin: "Kànlái nǐ duì Gemini 3 de fābù fēicháng xīngfèn! Zài YouTube shàng quèshí yǒu hěnduō guānyú réngōng zhìnéng (AI) de rèliè tǎolùn.", translation: "Parece que você está muito animado com o lançamento do Gemini 3! No YouTube, há realmente muitas discussões acaloradas sobre IA.", tokens: ["看来", "你对", "Gemini 3", "的发布", "非常兴奋！", "在 YouTube 上", "确实有", "很多关于", "人工智能", "的热烈讨论。"], keywords: [{ id: "w1-1", word: "兴奋", pinyin: "xīngfèn", meaning: "Animado / Empolgado" }, { id: "w1-2", word: "确实", pinyin: "quèshí", meaning: "Realmente / De fato" }, { id: "w1-3", word: "热烈", pinyin: "rèliè", meaning: "Acalorado / Entusiasmado" }] },
            { id: 2, chinese: "既然你想练习中文，而且对语音识别和深度思考感兴趣，我就用比较简单易懂的中文为你介绍一下。", pinyin: "Jìrán nǐ xiǎng liànxí zhōngwén, érqiě duì yǔyīn shíbié hé shēndù sīkǎo gǎn xìngqù, wǒ jiù yòng bǐjiào jiǎndān yìdǒng de zhōngwén wèi nǐ jièshào yīxià.", translation: "Já que você quer praticar chinês e se interessa por reconhecimento de voz e pensamento profundo, vou te apresentar isso usando um chinês simples e fácil de entender.", tokens: ["既然", "你想", "练习中文，", "而且对", "语音识别", "和", "深度思考", "感兴趣，", "我就用", "简单易懂的", "中文", "为你介绍一下。"], keywords: [{ id: "w2-1", word: "既然", pinyin: "jìrán", meaning: "Já que / Visto que" }, { id: "w2-2", word: "易懂", pinyin: "yìdǒng", meaning: "Fácil de entender" }, { id: "w2-3", word: "介绍", pinyin: "jièshào", meaning: "Apresentar / Introduzir" }] },
            { id: 3, chinese: "这里是对这两个领域的简单介绍：1. 语音识别 (Speech Recognition)", pinyin: "Zhèlǐ shì duì zhè liǎng gè lǐngyù de jiǎndān jièshào: 1. Yǔyīn shíbié", translation: "Aqui está uma breve introdução a essas duas áreas: 1. Reconhecimento de Voz", tokens: ["这里是", "对", "这两个", "领域的", "简单介绍：", "1. 语音识别"], keywords: [{ id: "w3-1", word: "领域", pinyin: "lǐngyù", meaning: "Campo / Área" }, { id: "w3-2", word: "介绍", pinyin: "jièshào", meaning: "Introdução" }] },
            { id: 4, chinese: "简单来说，这就是让电脑“听懂”人类的语言。", pinyin: "Jiǎndān lái shuō, zhè jiùshì ràng diànnǎo 'tīngdǒng' rénlèi de yǔyán.", translation: "Simplificando, é fazer o computador 'entender' a linguagem humana.", tokens: ["简单来说，", "这", "就是", "让电脑", "“听懂”", "人类的", "语言。"], keywords: [{ id: "w4-1", word: "简单来说", pinyin: "jiǎndān lái shuō", meaning: "Simplificando" }, { id: "w4-2", word: "听懂", pinyin: "tīngdǒng", meaning: "Entender (auditivamente)" }] },
            { id: 5, chinese: "它的工作原理：电脑把你的声音（声波）转换成文字。", pinyin: "Tā de gōngzuò yuánlǐ: Diànnǎo bǎ nǐ de shēngyīn (shēngbō) zhuǎnhuàn chéng wénzì.", translation: "Seu princípio de funcionamento: O computador converte sua voz (ondas sonoras) em texto.", tokens: ["它的", "工作原理：", "电脑", "把你的", "声音", "转换成", "文字。"], keywords: [{ id: "w5-1", word: "原理", pinyin: "yuánlǐ", meaning: "Princípio / Teoria" }, { id: "w5-2", word: "转换", pinyin: "zhuǎnhuàn", meaning: "Converter / Transformar" }] },
            { id: 6, chinese: "为什么它很厉害：以前的电脑只能听懂简单的指令。", pinyin: "Wèishéme tā hěn lìhài: Yǐqián de diànnǎo zhǐnéng tīngdǒng jiǎndān de zhǐlìng.", translation: "Por que isso é incrível: Computadores antigos só conseguiam entender comandos simples.", tokens: ["为什么", "它", "很厉害：", "以前的", "电脑", "只能", "听懂", "简单的", "指令。"], keywords: [{ id: "w6-1", word: "厉害", pinyin: "lìhài", meaning: "Incrível / Poderoso" }, { id: "w6-2", word: "指令", pinyin: "zhǐlìng", meaning: "Comando / Instrução" }] },
            { id: 7, chinese: "现在的 AI（比如 Gemini）可以理解语调 (Tones)：特别是在中文里，语调非常重要。", pinyin: "Xiànzài de AI (bǐrú Gemini) kěyǐ lǐjiě yǔdiào: Tèbié shì zài zhōngwén lǐ, yǔdiào fēicháng zhòngyào.", translation: "A IA atual (como Gemini) pode entender tons: especialmente em chinês, os tons são muito importantes.", tokens: ["现在的 AI", "可以", "理解", "语调：", "特别是", "在中文里，", "语调", "非常", "重要。"], keywords: [{ id: "w7-1", word: "语调", pinyin: "yǔdiào", meaning: "Entonação / Tom" }, { id: "w7-2", word: "特别", pinyin: "tèbié", meaning: "Especialmente" }] },
            { id: 8, chinese: "口音 (Accents): 哪怕你有口音，AI 也能大概猜出你在说什么。", pinyin: "Kǒuyīn: Nǎpà nǐ yǒu kǒuyīn, AI yě néng dàgài cāichū nǐ zài shuō shénme.", translation: "Sotaque: Mesmo se você tiver sotaque, a IA consegue adivinhar mais ou menos o que você está dizendo.", tokens: ["口音：", "哪怕", "你有", "口音，", "AI 也能", "大概", "猜出", "你", "在说什么。"], keywords: [{ id: "w8-1", word: "哪怕", pinyin: "nǎpà", meaning: "Mesmo que" }, { id: "w8-2", word: "大概", pinyin: "dàgài", meaning: "Provavelmente / Aproximadamente" }] },
            { id: 9, chinese: "语速 (Speed): 即使说话很快，它也能跟上。", pinyin: "Yǔsù: Jíshǐ shuōhuà hěn kuài, tā yě néng gēnshàng.", translation: "Velocidade da fala: Mesmo se falar rápido, ela consegue acompanhar.", tokens: ["语速：", "即使", "说话", "很快，", "它", "也能", "跟上。"], keywords: [{ id: "w9-1", word: "即使", pinyin: "jíshǐ", meaning: "Mesmo se" }, { id: "w9-2", word: "跟上", pinyin: "gēnshàng", meaning: "Acompanhar / Manter o ritmo" }] },
            { id: 10, chinese: "例子：当你对着手机说“设一个早上七点的闹钟”，手机立刻照做，这就是语音识别在工作。", pinyin: "Lìzi: Dāng nǐ duìzhe shǒujī shuō 'shè yīgè zǎoshang qīdiǎn de nàozhōng', shǒujī lìkè zhàozuò, zhè jiùshì yǔyīn shíbié zài gōngzuò.", translation: "Exemplo: Quando você diz ao celular 'defina um alarme para as sete da manhã' e ele faz imediatamente, isso é reconhecimento de voz em ação.", tokens: ["例子：", "当你", "对着手机", "说", "“设一个", "闹钟”，", "手机", "立刻", "照做，", "这", "就是", "语音识别", "在工作。"], keywords: [{ id: "w10-1", word: "立刻", pinyin: "lìkè", meaning: "Imediatamente" }, { id: "w10-2", word: "照做", pinyin: "zhàozuò", meaning: "Seguir instruções" }] },
            { id: 11, chinese: "2. 深度思考与识别 (Deep Thinking & Reasoning)", pinyin: "2. Shēndù sīkǎo yǔ shíbié", translation: "2. Pensamento Profundo e Reconhecimento", tokens: ["2.", "深度思考", "与", "识别"], keywords: [{ id: "w11-1", word: "深度", pinyin: "shēndù", meaning: "Profundidade / Profundo" }] },
            { id: 12, chinese: "你提到的“深度思考识别”，在 AI 领域通常指的是深度推理或自然语言理解。", pinyin: "Nǐ tídào de 'shēndù sīkǎo shíbié', zài AI lǐngyù tōngcháng zhǐ de shì shēndù tuīlǐ huò zìrán yǔyán lǐjiě.", translation: "O 'reconhecimento de pensamento profundo' que você mencionou geralmente se refere a Raciocínio Profundo ou Compreensão de Linguagem Natural na área de IA.", tokens: ["你提到的", "“深度思考识别”，", "在 AI 领域", "通常", "指的", "是", "深度推理", "或", "自然语言理解。"], keywords: [{ id: "w12-1", word: "通常", pinyin: "tōngcháng", meaning: "Geralmente" }, { id: "w12-2", word: "指", pinyin: "zhǐ", meaning: "Referir-se a / Apontar" }] },
            { id: 13, chinese: "这比简单的“听写”要复杂得多。", pinyin: "Zhè bǐ jiǎndān de 'tīngxiě' yào fùzá de duō.", translation: "Isso é muito mais complexo do que um simples 'ditado'.", tokens: ["这", "比", "简单的", "“听写”", "要", "复杂", "得多。"], keywords: [{ id: "w13-1", word: "听写", pinyin: "tīngxiě", meaning: "Ditado" }, { id: "w13-2", word: "复杂", pinyin: "fùzá", meaning: "Complexo" }] },
            { id: 14, chinese: "不仅是“听”，而是“懂”：以前的 AI 只是在找关键词。现在的 AI 会像人一样思考逻辑。", pinyin: "Bùjǐn shì 'tīng', érshì 'dǒng': Yǐqián de AI zhǐshì zài zhǎo guānjiàncí. Xiànzài de AI huì xiàng rén yīyàng sīkǎo luóji.", translation: "Não é apenas 'ouvir', mas 'entender': IAs antigas apenas procuravam palavras-chave. A IA atual pensa logicamente como um humano.", tokens: ["不仅是", "“听”，", "而是", "“懂”：", "以前的 AI", "只是", "在找", "关键词。", "现在的 AI", "会", "像人一样", "思考逻辑。"], keywords: [{ id: "w14-1", word: "不仅...而是", pinyin: "bùjǐn... érshì", meaning: "Não apenas... mas sim" }, { id: "w14-2", word: "逻辑", pinyin: "luóji", meaning: "Lógica" }] },
            { id: 15, chinese: "上下文 (Context): 它能记住我们前面说了什么。AI 能识别这个关系。", pinyin: "Shàngxiàwén: Tā néng jìzhù wǒmen qiánmiàn shuōle shénme. AI néng shíbié zhège guānxì.", translation: "Contexto: Ela consegue lembrar o que dissemos antes. A IA pode identificar essa relação.", tokens: ["上下文：", "它能", "记住", "我们", "前面", "说了什么。", "AI 能", "识别", "这个", "关系。"], keywords: [{ id: "w15-1", word: "上下文", pinyin: "shàngxiàwén", meaning: "Contexto" }, { id: "w15-2", word: "关系", pinyin: "guānxì", meaning: "Relação / Relacionamento" }] },
            { id: 16, chinese: "解决复杂问题：深度思考意味着 AI 可以一步一步地分析问题，而不是直接猜答案。", pinyin: "Jiějué fùzá wèntí: Shēndù sīkǎo yìwèizhe AI kěyǐ yībù yībù de fēnxī wèntí, ér bùshì zhíjiē cāi dá'àn.", translation: "Resolvendo problemas complexos: Pensamento profundo significa que a IA pode analisar problemas passo a passo, em vez de adivinhar a resposta.", tokens: ["解决", "复杂问题：", "深度思考", "意味着", "AI 可以", "一步一步地", "分析问题，", "而不是", "直接", "猜答案。"], keywords: [{ id: "w16-1", word: "解决", pinyin: "jiějué", meaning: "Resolver" }, { id: "w16-2", word: "意味着", pinyin: "yìwèizhe", meaning: "Significar" }] },
            { id: 17, chinese: "小贴士 (Tip for your Chinese): 你刚才说的句子有一点重复，可以这样更自然地表达：", pinyin: "Xiǎotiēshì: Nǐ gāngcái shuō de jùzi yǒu yīdiǎn chóngfù, kěyǐ zhèyàng gèng zìrán de biǎodá:", translation: "Dica (para seu chinês): A frase que você disse tem um pouco de repetição, você pode expressar de forma mais natural assim:", tokens: ["小贴士：", "你刚才", "说的句子", "有一点", "重复，", "可以", "这样", "更自然地", "表达："], keywords: [{ id: "w17-1", word: "重复", pinyin: "chóngfù", meaning: "Repetitivo / Repetir" }, { id: "w17-2", word: "表达", pinyin: "biǎodá", meaning: "Expressar" }] },
            { id: 18, chinese: "你写的：“我是从YouTube我是从YouTube上了解他这件事的。”", pinyin: "Nǐ xiě de: 'Wǒ shì cóng YouTube wǒ shì cóng YouTube shàng liǎojiě tā zhè jiàn shì de.'", translation: "O que você escreveu: 'Eu sou do YouTube eu sou do YouTube saber sobre ele isso.'", tokens: ["你写的：", "“我是从", "YouTube", "我是从", "YouTube 上", "了解他", "这件事的。”"], keywords: [{ id: "w18-1", word: "了解", pinyin: "liǎojiě", meaning: "Entender / Saber" }] },
            { id: 19, chinese: "更自然的说法：“我是从 YouTube 上了解到这件事的。”", pinyin: "Gèng zìrán de shuōfǎ: 'Wǒ shì cóng YouTube shàng liǎojiě dào zhè jiàn shì de.'", translation: "Forma mais natural: 'Eu fiquei sabendo disso através do YouTube.'", tokens: ["更自然的", "说法：", "“我是", "从 YouTube 上", "了解到", "这件", "事的。”"], keywords: [{ id: "w19-1", word: "自然", pinyin: "zìrán", meaning: "Natural" }, { id: "w19-2", word: "说法", pinyin: "shuōfǎ", meaning: "Maneira de dizer" }] },
            { id: 20, chinese: "下一步 (Next Step): 你想尝试用中文问我一个关于“语音识别”的具体问题吗？", pinyin: "Xià yī bù: Nǐ xiǎng chángshì yòng zhōngwén wèn wǒ yīgè guānyú 'yǔyīn shíbié' de jùtǐ wèntí ma?", translation: "Próximo passo: Você quer tentar me fazer uma pergunta específica sobre 'reconhecimento de voz' em chinês?", tokens: ["下一步：", "你想", "尝试", "用中文", "问我", "一个关于", "“语音识别”", "的", "具体问题吗？"], keywords: [{ id: "w20-1", word: "尝试", pinyin: "chángshì", meaning: "Tentar / Experimentar" }, { id: "w20-2", word: "具体", pinyin: "jùtǐ", meaning: "Específico" }] },
            { id: 21, chinese: "或者我们可以试着模拟一段对话，测试一下 AI 的理解能力？", pinyin: "Huòzhě wǒmen kěyǐ shìzhe mónǐ yīduàn duìhuà, cèshì yīxià AI de lǐjiě nénglì?", translation: "Ou podemos tentar simular um diálogo para testar a capacidade de compreensão da IA?", tokens: ["或者", "我们可以", "试着", "模拟", "一段对话，", "测试一下", "AI 的", "理解能力？"], keywords: [{ id: "w21-1", word: "模拟", pinyin: "mónǐ", meaning: "Simular" }, { id: "w21-2", word: "能力", pinyin: "nénglì", meaning: "Habilidade / Capacidade" }] }
        ];

        // --- HELPERS ---
        const Icon = ({ name, size = 24, className = "" }) => {
            useEffect(() => { if(window.lucide) window.lucide.createIcons(); }, [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        const speak = (text) => {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN'; utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
        };

        // --- HOOK DE ESTATÍSTICAS ---
        const useStats = () => {
            const [stats, setStats] = useState({ correct: 0, wrong: 0, history: [], wordCounts: {} });

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('mandarin_hsk_stats');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (!parsed.wordCounts) parsed.wordCounts = {};
                        setStats(parsed);
                    }
                } catch (e) {}
            }, []);

            const recordResult = (isCorrect, word, type = 'general') => {
                setStats(prev => {
                    const currentCounts = prev.wordCounts || {};
                    const newCount = !isCorrect ? (currentCounts[word] || 0) + 1 : (currentCounts[word] || 0);
                    
                    const newStats = {
                        correct: prev.correct + (isCorrect ? 1 : 0),
                        wrong: prev.wrong + (!isCorrect ? 1 : 0),
                        history: !isCorrect 
                            ? [{ word, date: new Date().toLocaleDateString('pt-BR'), time: new Date().toLocaleTimeString('pt-BR'), type }, ...prev.history].slice(0, 50) 
                            : prev.history,
                        wordCounts: { ...currentCounts, [word]: newCount }
                    };
                    localStorage.setItem('mandarin_hsk_stats', JSON.stringify(newStats));
                    return newStats;
                });
            };

            const clearStats = () => {
                const empty = { correct: 0, wrong: 0, history: [], wordCounts: {} };
                setStats(empty);
                localStorage.setItem('mandarin_hsk_stats', JSON.stringify(empty));
            };

            return { stats, recordResult, clearStats };
        };

        // --- HEADER ---
        const Header = ({ onOpenStats, onOpenPronounce }) => (
            <header className="bg-brand-700 text-white px-4 py-3 flex justify-between items-center shadow-md flex-shrink-0 z-20">
                <div className="flex items-center gap-2"><Icon name="brain-circuit" size={24} className="text-white" /><h1 className="text-lg font-bold tracking-tight">Mandarim</h1></div>
                <div className="flex items-center gap-3">
                    <button onClick={onOpenPronounce} className="bg-white/20 p-2 rounded-full hover:bg-white/30 transition-colors mr-1">
                        <Icon name="mic" size={18} />
                    </button>
                    <button onClick={onOpenStats} className="bg-white/20 p-2 rounded-full hover:bg-white/30 transition-colors">
                        <Icon name="bar-chart-2" size={18} />
                    </button>
                    <div className="bg-white/20 px-2 py-1 rounded text-xs font-medium backdrop-blur-sm">Deep Thinking</div>
                </div>
            </header>
        );

        const NavBtn = ({ id, label, icon, active, setTab, highlight }) => {
            const isActive = active === id;
            return (
                <button onClick={() => setTab(id)} className={`flex flex-col items-center justify-center w-full h-full pt-2 pb-2 transition-all ${isActive ? 'text-brand-700' : 'text-slate-400 hover:text-slate-600'}`}>
                    <div className={`mb-1 p-1 rounded-xl transition-all duration-300 ${isActive ? 'bg-brand-100 px-4' : ''} ${!isActive && highlight ? 'text-brand-500' : ''}`}><Icon name={icon} size={20} className={isActive ? "stroke-[2.5]" : "stroke-2"} /></div><span className="text-[10px] font-bold tracking-wide">{label}</span>
                </button>
            );
        };

        const EmptyState = ({ msg, icon = "bookmark" }) => (<div className="flex flex-col items-center justify-center h-full text-slate-400 p-8 text-center"><div className="bg-slate-100 p-6 rounded-full mb-4"><Icon name={icon} size={32} className="opacity-50" /></div><p className="font-medium">{msg}</p></div>);

        // --- MÓDULO DE PRONÚNCIA (COM PINYIN MATCHING) ---
        const PronunciationModal = ({ data, onClose, onResult }) => {
            const [target, setTarget] = useState(null);
            const [status, setStatus] = useState('idle');
            const [transcript, setTranscript] = useState('');
            const [errorMsg, setErrorMsg] = useState('');

            useEffect(() => {
                const allKeywords = data.flatMap(s => s.keywords);
                const random = allKeywords[Math.floor(Math.random() * allKeywords.length)];
                setTarget(random);
            }, []);

            // Lógica de Comparação Inteligente (Pinyin)
            const checkSimilarity = (input, targetWord) => {
                if (!input) return false;
                
                // 1. Limpeza básica
                const cleanInput = input.replace(/[.,\/#!$%\^&\*;:{}=\-_`~() ]/g,"").toLowerCase();
                const cleanTarget = targetWord.replace(/[.,\/#!$%\^&\*;:{}=\-_`~() ]/g,"").toLowerCase();
                
                // 2. Verifica se o caractere exato está contido
                if (cleanInput.includes(cleanTarget) || cleanTarget.includes(cleanInput)) return true;

                // 3. Verifica via PINYIN (Resolve homófonos como zhǐ/纸 vs 指)
                try {
                    const pinyinInput = pinyin(cleanInput, { toneType: 'none', type: 'array' }).join('').toLowerCase();
                    const pinyinTarget = pinyin(cleanTarget, { toneType: 'none', type: 'array' }).join('').toLowerCase();
                    
                    return pinyinInput.includes(pinyinTarget) || pinyinTarget.includes(pinyinInput);
                } catch (e) {
                    console.error("Erro na conversão Pinyin", e);
                    return false;
                }
            }

            const startListening = () => {
                setErrorMsg('');
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    setErrorMsg("Navegador sem suporte a voz."); return;
                }

                try {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    recognition.lang = 'zh-CN';
                    recognition.interimResults = false;
                    recognition.maxAlternatives = 1;

                    recognition.onstart = () => setStatus('listening');
                    
                    recognition.onresult = (event) => {
                        const result = event.results[0][0].transcript;
                        setTranscript(result);
                        
                        if (checkSimilarity(result, target.word)) {
                            setStatus('success');
                            onResult(true, target.word, 'pronunciation');
                            speak("非常好");
                            setTimeout(() => {
                                const allKeywords = data.flatMap(s => s.keywords);
                                setTarget(allKeywords[Math.floor(Math.random() * allKeywords.length)]);
                                setStatus('idle');
                                setTranscript('');
                            }, 1500);
                        } else {
                            setStatus('error');
                            onResult(false, target.word, 'pronunciation');
                        }
                    };

                    recognition.onerror = (e) => {
                        setStatus('idle');
                        if (e.error === 'not-allowed') setErrorMsg("Permissão negada. Use HTTPS.");
                        else if (e.error === 'no-speech') setErrorMsg("Nenhuma fala detectada.");
                        else setErrorMsg("Erro: " + e.error);
                    };

                    recognition.onend = () => { if (status === 'listening') setStatus('idle'); };
                    recognition.start();
                } catch (e) { setErrorMsg("Erro ao iniciar microfone."); }
            };

            if (!target) return null;

            return (
                <div className="fixed inset-0 z-[70] bg-black/80 backdrop-blur-sm flex items-center justify-center animate-pop p-4">
                    <div className="bg-white w-full max-w-sm rounded-2xl shadow-2xl p-6 relative flex flex-col items-center">
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600"><Icon name="x" size={24} /></button>
                        <h2 className="text-sm font-bold text-slate-400 uppercase tracking-widest mb-6">Treino de Pronúncia</h2>
                        <div className="mb-8 text-center">
                            <p className="text-5xl font-chinese font-bold text-slate-800 mb-2">{target.word}</p>
                            <p className="text-xl text-brand-600 font-medium">{target.pinyin}</p>
                        </div>
                        <div className={`w-full bg-slate-50 rounded-xl p-4 mb-6 min-h-[60px] flex items-center justify-center text-center border-2 transition-colors ${status === 'success' ? 'border-brand-500 bg-brand-50' : status === 'error' ? 'border-red-400 bg-red-50' : 'border-slate-100'}`}>
                            {status === 'listening' && <p className="text-slate-400 animate-pulse">Ouvindo...</p>}
                            {(status === 'success' || status === 'error') && <p className={`font-chinese text-lg ${status === 'success' ? 'text-brand-700' : 'text-red-600'}`}>{transcript || "..."}</p>}
                            {status === 'idle' && !errorMsg && <p className="text-slate-300 text-sm">Toque no microfone e fale</p>}
                            {errorMsg && <p className="text-red-500 text-xs font-bold">{errorMsg}</p>}
                        </div>
                        <button onMouseDown={startListening} onTouchStart={startListening} className={`p-6 rounded-full shadow-lg transition-all active:scale-95 ${status === 'listening' ? 'bg-red-500 text-white animate-pulse' : 'bg-brand-600 text-white hover:bg-brand-700'}`}><Icon name="mic" size={32} /></button>
                    </div>
                </div>
            );
        };

        // --- STATS MODAL ---
        const StatsModal = ({ stats, onClose, onClear }) => {
            if (!stats) return null;
            const total = stats.correct + stats.wrong;
            const accuracy = total > 0 ? Math.round((stats.correct / total) * 100) : 0;
            return (
                <div className="fixed inset-0 z-[60] bg-black/50 backdrop-blur-sm flex items-end sm:items-center justify-center animate-pop">
                    <div className="bg-white w-full max-w-md sm:rounded-2xl rounded-t-2xl shadow-2xl h-[80vh] flex flex-col overflow-hidden animate-slide-up sm:animate-none">
                        <div className="p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50"><h2 className="text-lg font-bold text-slate-800 flex items-center gap-2"><Icon name="activity" size={20} className="text-brand-600"/> Desempenho</h2><button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600"><Icon name="x" size={24} /></button></div>
                        <div className="p-6 overflow-y-auto flex-1">
                            <div className="grid grid-cols-2 gap-4 mb-6"><div className="bg-brand-50 p-4 rounded-xl border border-brand-100 text-center"><span className="block text-3xl font-bold text-brand-600 mb-1">{stats.correct}</span><span className="text-xs font-bold text-brand-400 uppercase tracking-wider">Acertos</span></div><div className="bg-red-50 p-4 rounded-xl border border-red-100 text-center"><span className="block text-3xl font-bold text-red-500 mb-1">{stats.wrong}</span><span className="text-xs font-bold text-red-300 uppercase tracking-wider">Erros</span></div></div>
                            <div className="bg-slate-800 text-white p-4 rounded-xl mb-6 flex justify-between items-center shadow-lg"><div><p className="text-xs opacity-60 uppercase font-bold tracking-wider">Precisão Global</p><p className="text-2xl font-bold">{accuracy}%</p></div><div className="h-10 w-10 rounded-full border-4 border-white/20 flex items-center justify-center"><span className="text-xs font-bold">{total > 0 ? (accuracy >= 80 ? 'A+' : accuracy >= 60 ? 'B' : 'C') : '-'}</span></div></div>
                            <h3 className="font-bold text-slate-700 mb-3 flex items-center gap-2 text-sm uppercase tracking-wide"><Icon name="history" size={16} /> Histórico de Erros</h3>
                            {stats.history.length === 0 ? <p className="text-center text-slate-400 text-sm py-4">Nenhum erro registrado ainda.</p> : 
                                <div className="space-y-2">
                                    {stats.history.map((entry, idx) => (
                                        <div key={idx} className="flex justify-between items-center p-3 bg-red-50/50 rounded-lg border border-red-50">
                                            <div className="flex items-center gap-2">
                                                <span className="font-chinese font-bold text-slate-700 text-lg">{entry.word}</span>
                                                {stats.wordCounts && stats.wordCounts[entry.word] > 1 && (<span className="bg-red-200 text-red-800 text-[10px] font-bold px-2 py-0.5 rounded-full shadow-sm">{stats.wordCounts[entry.word]}x</span>)}
                                            </div>
                                            <div className="text-right">
                                                <span className="block text-[10px] font-bold text-red-400 uppercase">{entry.type === 'pronunciation' ? 'Pronúncia' : 'Erro'}</span>
                                                <span className="block text-[10px] text-slate-400">{entry.date}</span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            }
                        </div>
                        <div className="p-4 border-t border-slate-100 bg-white"><button onClick={onClear} className="w-full py-3 text-sm text-slate-400 hover:text-red-500 font-medium transition-colors flex items-center justify-center gap-2"><Icon name="trash-2" size={16} /> Limpar Histórico</button></div>
                    </div>
                </div>
            );
        };

        // --- VIEWS ---
        const ReadingView = ({ data, savedIds, onToggleSave }) => {
            const renderSentence = (sentence) => {
                let text = sentence.chinese;
                const sortedKw = [...sentence.keywords].sort((a, b) => b.word.length - a.word.length);
                const pattern = new RegExp(`(${sortedKw.map(k => k.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'g');
                return text.split(pattern).map((part, i) => {
                    const kw = sentence.keywords.find(k => k.word === part);
                    if (kw) {
                        const isSaved = savedIds.includes(kw.id);
                        return <span key={i} onClick={(e) => { e.stopPropagation(); onToggleSave(kw.id); if(!isSaved) speak(kw.word); }} className={`inline-block px-1 mx-0.5 rounded cursor-pointer transition-colors border-b-2 ${isSaved ? 'bg-brand-100 text-brand-800 border-brand-500 font-medium' : 'hover:bg-slate-100 border-slate-300 border-dotted'}`}>{part}</span>;
                    } return <span key={i}>{part}</span>;
                });
            };
            return (
                <div className="p-4 space-y-4 pb-24">
                    <div className="bg-white p-3 rounded-lg shadow-sm border border-slate-100 flex items-center gap-2 text-sm text-slate-500"><Icon name="info" size={16} /><span>Toque nas palavras para salvar.</span></div>
                    {data.map((item) => (<div key={item.id} className="bg-white rounded-xl p-5 shadow-sm border border-slate-100"><div className="flex justify-between items-start gap-4"><div className="font-chinese text-xl leading-loose text-slate-800 flex-1 break-words">{renderSentence(item)}</div><button onClick={() => speak(item.chinese)} className="text-brand-600 bg-brand-50 p-2 rounded-full hover:bg-brand-100 flex-shrink-0"><Icon name="volume-2" size={18} /></button></div><div className="mt-3 pt-3 border-t border-slate-50"><p className="text-slate-500 text-sm italic">{item.translation}</p></div></div>))}
                </div>
            );
        };

        const ReviewView = ({ data, savedIds, onRemove }) => {
            const [expandedId, setExpandedId] = useState(null);
            const savedItems = useMemo(() => { let items = []; data.forEach(s => s.keywords.forEach(k => { if (savedIds.includes(k.id)) items.push({ ...k, sentence: s }); })); return items; }, [savedIds]);
            if (savedItems.length === 0) return <EmptyState msg="Marque palavras na Leitura para revisar aqui." />;
            return (
                <div className="p-4 space-y-3 pb-24">
                    <h2 className="font-bold text-slate-800 text-lg mb-4 flex items-center gap-2"><Icon name="bookmark" size={20} className="text-brand-600"/> Revisão ({savedItems.length})</h2>
                    {savedItems.map(item => (
                        <div key={item.id} className="bg-white rounded-lg shadow-sm border border-slate-100 overflow-hidden">
                            <div className="flex items-center justify-between p-4"><h3 className="font-chinese text-xl font-bold text-brand-700">{item.word}</h3><div className="flex items-center gap-3"><button onClick={() => setExpandedId(expandedId === item.id ? null : item.id)} className="text-xs text-slate-400 hover:text-brand-600 font-medium uppercase tracking-wide">{expandedId === item.id ? 'Recolher' : 'Detalhes'}</button><button onClick={() => onRemove(item.id)} className="text-red-400 hover:text-red-600"><Icon name="trash-2" size={18} /></button></div></div>
                            {expandedId === item.id && (<div className="bg-slate-50 p-4 border-t border-slate-100 animate-pop"><div className="mb-3"><p className="font-medium text-brand-600 text-lg">{item.pinyin}</p><p className="text-slate-600">{item.meaning}</p></div><div className="bg-white p-3 rounded border border-slate-200"><span className="text-[10px] text-slate-400 font-bold uppercase mb-1 block">Contexto</span><p className="font-chinese text-slate-800 mb-1">{item.sentence.chinese}</p><p className="text-xs text-slate-500 italic">{item.sentence.translation}</p></div></div>)}
                        </div>
                    ))}
                </div>
            );
        };

        const PracticeView = ({ data, savedIds, onResult }) => {
            const [session, setSession] = useState(null); const [isFinished, setIsFinished] = useState(false); const [feedback, setFeedback] = useState(null);
            const resetGame = () => {
                setIsFinished(false); setFeedback(null); setSession(null); 
                setTimeout(() => {
                    const savedKeywords = []; data.forEach(s => s.keywords.forEach(k => { if (savedIds.includes(k.id)) savedKeywords.push({ ...k, fullSentence: s }); }));
                    if (savedKeywords.length === 0) return;
                    const shuffled = savedKeywords.sort(() => 0.5 - Math.random());
                    const queue = shuffled.slice(0, 6).map(target => {
                        const allWords = data.flatMap(s => s.keywords).filter(k => k.id !== target.id);
                        const distractors = allWords.sort(() => 0.5 - Math.random()).slice(0, 3).map(k => k.word);
                        const options = [target.word, ...distractors].sort(() => 0.5 - Math.random());
                        const clozeSentence = target.fullSentence.chinese.replace(target.word, " ____ ");
                        return { target, options, clozeSentence };
                    }); setSession({ queue, currentIndex: 0, score: 0 });
                }, 50);
            };
            useEffect(() => { if (!session && !isFinished && savedIds.length > 0) resetGame(); }, [savedIds]);
            const handleAnswer = (ans) => {
                if (feedback) return; const currentQ = session.queue[session.currentIndex]; const isCorrect = ans === currentQ.target.word; onResult(isCorrect, currentQ.target.word);
                if (isCorrect) { setFeedback('correct'); speak(currentQ.target.word); } else { setFeedback('wrong'); }
                setTimeout(() => {
                    const isLast = session.currentIndex >= session.queue.length - 1;
                    setSession(prev => ({ ...prev, score: prev.score + (isCorrect ? 1 : 0), currentIndex: isLast ? prev.currentIndex : prev.currentIndex + 1 }));
                    if (isLast) setIsFinished(true); else setFeedback(null);
                }, 1200);
            };
            if (savedIds.length === 0) return <EmptyState msg="Salve palavras para praticar." icon="pen-tool" />; if (!session) return <div className="p-10 text-center text-slate-400">Carregando...</div>;
            if (isFinished) { return (<div className="p-6 h-full flex flex-col items-center justify-center max-w-md mx-auto animate-pop pb-24"><div className="bg-brand-100 text-brand-600 p-6 rounded-full mb-6"><Icon name="trophy" size={48} /></div><h2 className="text-2xl font-bold text-slate-800 mb-2">Sessão Concluída!</h2><p className="text-slate-500 mb-8 text-center">Você acertou <strong className="text-brand-600">{session.score}</strong> de {session.queue.length} palavras.</p><button onClick={resetGame} className="w-full py-4 bg-brand-600 text-white rounded-xl font-bold shadow-lg shadow-brand-200 hover:bg-brand-700 transition-all flex items-center justify-center gap-2"><Icon name="refresh-cw" size={20} /> Praticar Novamente</button></div>); }
            const currentQ = session.queue[session.currentIndex]; const progress = ((session.currentIndex + 1) / session.queue.length) * 100;
            return (
                <div className="p-4 flex flex-col h-full justify-center max-w-md mx-auto pb-24">
                    <div className="mb-6"><div className="flex justify-between text-xs font-bold text-slate-400 mb-1 uppercase"><span>Questão {session.currentIndex + 1}</span><span>{session.queue.length}</span></div><div className="h-2 bg-slate-200 rounded-full overflow-hidden"><div className="h-full bg-brand-500 transition-all duration-500" style={{ width: `${progress}%` }}></div></div></div>
                    <div className="bg-white rounded-2xl shadow-lg p-6 border-t-4 border-brand-500 mb-6 relative overflow-hidden min-h-[200px] flex flex-col justify-center">{feedback === 'correct' && <div className="absolute inset-0 bg-brand-500/10 flex items-center justify-center z-10"><Icon name="check-circle" size={64} className="text-brand-600 animate-pop" /></div>}{feedback === 'wrong' && <div className="absolute inset-0 bg-red-500/10 flex items-center justify-center z-10"><Icon name="x-circle" size={64} className="text-red-500 animate-shake" /></div>}<p className="font-chinese text-2xl text-center leading-loose text-slate-800 mb-6">{currentQ.clozeSentence}</p><p className="text-sm text-center text-slate-400 italic border-t border-slate-100 pt-4">{currentQ.target.fullSentence.translation}</p></div>
                    <div className="grid grid-cols-2 gap-4" key={session.currentIndex}>{currentQ.options.map((opt, i) => (<button key={i} onClick={() => handleAnswer(opt)} disabled={feedback !== null} className={`border-2 rounded-xl py-4 text-xl font-chinese font-bold transition-all active:scale-95 ${feedback === null ? 'bg-white border-slate-200 text-slate-700 hover:border-brand-500 hover:bg-brand-50' : opt === currentQ.target.word ? 'bg-brand-500 border-brand-500 text-white' : 'bg-slate-50 border-slate-100 text-slate-300'}`}>{opt}</button>))}</div>
                </div>
            );
        };

        const GameView = ({ data, onResult }) => {
            const [pool, setPool] = useState([]);
            const [selected, setSelected] = useState(null); 
            const [matchedList, setMatchedList] = useState([]);
            const [isWrong, setIsWrong] = useState(false);

            useEffect(() => {
                const initGame = () => {
                    try {
                        const localStats = localStorage.getItem('mandarin_hsk_stats');
                        const history = localStats ? JSON.parse(localStats).history : [];
                        const today = new Date().toLocaleDateString('pt-BR');
                        const recentErrors = history.filter(h => h.date === today).map(h => h.word);
                        let uniqueErrors = [...new Set(recentErrors)];

                        if (uniqueErrors.length < 4) {
                            const allKeywords = data.flatMap(s => s.keywords);
                            const randomFill = allKeywords.sort(() => 0.5 - Math.random()).slice(0, 6).map(k => k.word);
                            uniqueErrors = [...new Set([...uniqueErrors, ...randomFill])];
                        }

                        let gameWords = [];
                        data.forEach(sentence => {
                            sentence.keywords.forEach(kw => {
                                if (uniqueErrors.includes(kw.word)) {
                                    if (!gameWords.find(gw => gw.word === kw.word)) {
                                        gameWords.push(kw);
                                    }
                                }
                            });
                        });

                        gameWords = gameWords.slice(0, 6);
                        let items = [];
                        gameWords.forEach((item, index) => {
                            items.push({ id: `h-${index}`, wordId: item.word, content: item.word, type: 'hanzi' });
                            items.push({ id: `t-${index}`, wordId: item.word, content: item.meaning, type: 'trans' });
                        });

                        setPool(items.sort(() => 0.5 - Math.random()));
                        setMatchedList([]);
                    } catch (e) { console.error("Erro init jogo", e); }
                };
                initGame();
            }, [data]);

            const handleCardClick = (item) => {
                if (isWrong) return; 
                if (selected && selected.id === item.id) { setSelected(null); return; }

                if (!selected) {
                    setSelected(item);
                } else {
                    if (selected.wordId === item.wordId) {
                        const hanziWord = selected.type === 'hanzi' ? selected.content : item.content;
                        const transWord = selected.type === 'trans' ? selected.content : item.content;
                        onResult(true, hanziWord); speak(hanziWord);
                        setMatchedList(prev => [...prev, { hanzi: hanziWord, trans: transWord }]);
                        setPool(prev => prev.filter(i => i.wordId !== item.wordId));
                        setSelected(null);
                    } else {
                        const errorWord = selected.type === 'hanzi' ? selected.content : item.content;
                        onResult(false, errorWord);
                        setIsWrong(true);
                        setTimeout(() => { setSelected(null); setIsWrong(false); }, 500);
                    }
                }
            };

            if (pool.length === 0 && matchedList.length === 0) return <EmptyState msg="Carregando jogo..." icon="gamepad-2" />;

            if (pool.length === 0 && matchedList.length > 0) {
                return (
                    <div className="p-6 h-full flex flex-col items-center justify-center animate-pop">
                        <div className="bg-brand-100 text-brand-600 p-6 rounded-full mb-6"><Icon name="trophy" size={48} /></div>
                        <h2 className="text-2xl font-bold text-slate-800 mb-6">Limpeza Concluída!</h2>
                        <div className="w-full bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
                            {matchedList.map((m, i) => (<div key={i} className="flex justify-between p-4 border-b border-slate-50 last:border-0"><span className="font-chinese font-bold text-slate-800">{m.hanzi}</span><span className="text-slate-500 text-sm truncate max-w-[50%]">{m.trans}</span></div>))}
                        </div>
                    </div>
                );
            }

            return (
                <div className="p-4 flex flex-col h-full pb-24">
                    <div className="flex-none mb-4 min-h-[60px]">
                        {matchedList.length > 0 ? (
                            <div className="flex gap-2 overflow-x-auto pb-2 no-scrollbar">{matchedList.map((m, i) => (<div key={i} className="flex-none bg-brand-50 border border-brand-100 px-3 py-2 rounded-lg flex flex-col animate-pop"><span className="font-chinese font-bold text-brand-700 text-sm">{m.hanzi}</span></div>))}</div>
                        ) : <p className="text-center text-slate-400 text-sm py-4 italic">Combine os pares...</p>}
                    </div>
                    <div className="flex-1 overflow-y-auto no-scrollbar">
                        <div className="grid grid-cols-2 gap-3 pb-4">
                            {pool.map((item) => (
                                <button key={item.id} onClick={() => handleCardClick(item)} className={`p-4 rounded-xl border-2 transition-all duration-200 min-h-[80px] flex items-center justify-center text-center shadow-sm relative overflow-hidden ${selected?.id === item.id ? (isWrong ? 'border-red-400 bg-red-50 animate-shake' : 'border-brand-500 bg-brand-50 -translate-y-1 shadow-md') : 'border-slate-200 bg-white hover:border-brand-200'}`}>
                                    <span className={`${item.type === 'hanzi' ? 'font-chinese text-2xl font-bold' : 'text-sm font-medium'} text-slate-700`}>{item.content}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const LabView = ({ data, savedIds, onResult }) => {
            const [puzzle, setPuzzle] = useState(null); const [userOrder, setUserOrder] = useState([]); const [pool, setPool] = useState([]); const [status, setStatus] = useState('idle'); 
            const initPuzzle = () => { const validSentences = data.filter(s => s.keywords.some(k => savedIds.includes(k.id))); if (validSentences.length === 0) return null; const target = validSentences[Math.floor(Math.random() * validSentences.length)]; const shuffled = [...target.tokens].sort(() => 0.5 - Math.random()); return { target, shuffledItems: shuffled.map((txt, i) => ({ id: i, text: txt, used: false })) }; };
            useEffect(() => { if (!puzzle) { const p = initPuzzle(); if(p) { setPuzzle(p); setPool(p.shuffledItems); setUserOrder([]); setStatus('idle'); } } }, [savedIds, puzzle]);
            const handleSelect = (idx) => { if(status === 'success') return; const item = pool[idx]; const nextIndex = userOrder.length; if (item.text !== puzzle.target.tokens[nextIndex]) { setStatus('error'); onResult(false, puzzle.target.tokens[nextIndex] + " (Ordem)"); setTimeout(() => setStatus('idle'), 500); return; } const newPool = [...pool]; newPool[idx].used = true; setPool(newPool); const newOrder = [...userOrder, item]; setUserOrder(newOrder); if (newOrder.length === puzzle.target.tokens.length) { setStatus('success'); onResult(true, "Sentença Completa"); speak(puzzle.target.chinese); } };
            const reset = () => setPuzzle(null);
            if (savedIds.length === 0) return <EmptyState msg="Precisa de vocabulário para o laboratório." icon="flask-conical" />; if (!puzzle) return <div className="p-10 text-center text-slate-400">Carregando...</div>;
            return (
                <div className="p-4 flex flex-col h-full max-w-md mx-auto pb-24">
                    <div className="bg-slate-800 rounded-xl p-4 mb-4 shadow-lg"><span className="text-[10px] text-brand-400 font-bold uppercase tracking-widest">Alvo</span><p className="text-white text-lg leading-relaxed">{puzzle.target.translation}</p></div>
                    <div className={`bg-white border-2 rounded-xl min-h-[100px] p-3 mb-6 flex flex-wrap gap-2 content-start transition-colors ${status === 'error' ? 'border-red-400 bg-red-50 animate-shake' : 'border-slate-200'} ${status === 'success' ? 'border-brand-500 bg-brand-50' : ''}`}>{userOrder.length === 0 && <span className="text-slate-300 w-full text-center self-center">Toque nas palavras abaixo</span>}{userOrder.map((item, i) => (<span key={i} className="bg-brand-600 text-white px-2 py-1 rounded shadow animate-pop">{item.text}</span>))}</div>
                    <div className="flex flex-wrap justify-center gap-3 mb-auto">{pool.map((item, i) => (<button key={i} onClick={() => !item.used && handleSelect(i)} className={`px-4 py-2 rounded-lg text-lg font-chinese shadow-sm border-b-2 transition-all ${item.used ? 'opacity-0 pointer-events-none scale-90' : 'bg-white text-slate-700 border-slate-300 hover:bg-slate-50 active:translate-y-1 active:border-b-0'}`}>{item.text}</button>))}</div>
                    {status === 'success' && (<button onClick={reset} className="w-full py-3 bg-brand-600 text-white rounded-xl font-bold shadow-lg animate-pop mt-4">Próximo Desafio</button>)}
                </div>
            );
        };

        const CardsView = ({ data, savedIds, onResult }) => {
            const [idx, setIdx] = useState(0); const [flipped, setFlipped] = useState(false);
            const cards = useMemo(() => { let list = []; data.forEach(s => s.keywords.forEach(k => { if (savedIds.includes(k.id)) list.push({...k, sentence: s}); })); return list.sort(() => 0.5 - Math.random()); }, [savedIds]);
            if (cards.length === 0) return <EmptyState msg="Sem cards para revisar." icon="layers" />;
            const card = cards[idx]; const next = (correct) => { onResult(correct, card.word); setFlipped(false); setTimeout(() => setIdx((idx + 1) % cards.length), 200); };
            return (
                <div className="p-6 h-full flex flex-col items-center justify-center max-w-md mx-auto pb-24">
                    <div className="relative w-full aspect-[3/4] cursor-pointer perspective-1000 group" onClick={() => setFlipped(!flipped)}><div className={`w-full h-full transition-all duration-500 transform-style-3d shadow-2xl rounded-2xl ${flipped ? 'rotate-y-180' : ''}`}><div className="absolute inset-0 bg-white rounded-2xl flex flex-col items-center justify-center backface-hidden border-b-4 border-slate-100"><span className="text-xs text-slate-400 uppercase tracking-widest mb-4">Hanzi</span><h2 className="text-6xl font-chinese font-bold text-slate-800">{card.word}</h2><span className="mt-8 text-xs text-brand-500 font-bold">Toque para virar</span></div><div className="absolute inset-0 bg-slate-800 rounded-2xl flex flex-col items-center justify-center rotate-y-180 backface-hidden text-white p-6 text-center"><h2 className="text-3xl font-chinese font-bold mb-2">{card.word}</h2><p className="text-brand-400 text-xl mb-4">{card.pinyin}</p><p className="text-lg mb-6 opacity-90">{card.meaning}</p><div className="bg-white/10 p-3 rounded text-sm italic">{card.sentence.chinese}</div></div></div></div>
                    <div className={`flex gap-4 mt-8 w-full transition-opacity duration-300 ${flipped ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}><button onClick={() => next(false)} className="flex-1 py-3 rounded-xl bg-red-100 text-red-600 font-bold shadow-sm active:scale-95 transition-transform">Errei</button><button onClick={() => next(true)} className="flex-1 py-3 rounded-xl bg-brand-100 text-brand-700 font-bold shadow-sm active:scale-95 transition-transform">Acertei</button></div>
                </div>
            );
        };

        // --- APP ---
        const App = () => {
            const [tab, setTab] = useState('leitura'); const [savedIds, setSavedIds] = useState([]); const [showStats, setShowStats] = useState(false); const [showPronounce, setShowPronounce] = useState(false);
            const { stats, recordResult, clearStats } = useStats(); 

            useEffect(() => { try { const localSaved = localStorage.getItem('mandarin_hsk_recovery'); if (localSaved) setSavedIds(JSON.parse(localSaved)); } catch (e) {} }, []);
            
            const toggleSave = (id) => { const newIds = savedIds.includes(id) ? savedIds.filter(i => i !== id) : [...savedIds, id]; setSavedIds(newIds); localStorage.setItem('mandarin_hsk_recovery', JSON.stringify(newIds)); };

            return (
                <div className="h-[100dvh] flex flex-col bg-slate-50 w-full overflow-hidden relative">
                    <Header onOpenStats={() => setShowStats(true)} onOpenPronounce={() => setShowPronounce(true)} />
                    <main className="flex-1 overflow-y-auto w-full no-scrollbar"><div className="max-w-3xl mx-auto h-full">
                        {tab === 'leitura' && <ReadingView data={studyData} savedIds={savedIds} onToggleSave={toggleSave} />}
                        {tab === 'revisao' && <ReviewView data={studyData} savedIds={savedIds} onRemove={toggleSave} />}
                        {tab === 'pratica' && <PracticeView data={studyData} savedIds={savedIds} onResult={recordResult} />}
                        {tab === 'jogo' && <GameView data={studyData} onResult={recordResult} />}
                        {tab === 'lab' && <LabView data={studyData} savedIds={savedIds} onResult={recordResult} />}
                        {tab === 'cards' && <CardsView data={studyData} savedIds={savedIds} onResult={recordResult} />}
                    </div></main>
                    <nav className="fixed bottom-0 w-full bg-white border-t border-slate-200 shadow-[0_-5px_20px_rgba(0,0,0,0.03)] z-50 h-[70px] flex justify-around items-center pb-safe">
                        <NavBtn id="leitura" label="Leitura" icon="book-open" active={tab} setTab={setTab} />
                        <NavBtn id="revisao" label="Revisão" icon="list" active={tab} setTab={setTab} />
                        <NavBtn id="pratica" label="Prática" icon="pen-tool" active={tab} setTab={setTab} />
                        <NavBtn id="jogo" label="Jogo" icon="gamepad-2" active={tab} setTab={setTab} />
                        <NavBtn id="lab" label="Lab" icon="flask-conical" active={tab} setTab={setTab} highlight />
                        <NavBtn id="cards" label="Cards" icon="layers" active={tab} setTab={setTab} />
                    </nav>
                    
                    {showStats && <StatsModal stats={stats} onClose={() => setShowStats(false)} onClear={clearStats} />}
                    {showPronounce && <PronunciationModal data={studyData} onClose={() => setShowPronounce(false)} onResult={recordResult} />}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>